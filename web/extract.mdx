import OptionsTable from "../../components/OptionsTable.tsx";
import { Link } from "react-router-dom";

# Action: `extract`

The `extract` action generate a JSON datastructure from the current page, according to the provided schema. By default, it writes this datastructure to the result datastore as a result, making it available for you to download after the Run's conclusion.

In addition, the data structure extracted with the `extract` action is merged in to the input State's `data` and this new `data` object is available to all subsequent steps in the pipeline.

This step can also be used to operate on the data from previous steps, ignoring the current State (see the `render` and `write` options and the section on [Special Values](/values)).

## Example

```json
{
  "action": "extract",
  "goal": "Get the basic information about the blog post",
  "schema": {
    "title": {
        "type": "string",
        "description": "Blog post title"
    },
    "authors" {
        "type": "array",
        "items": {
            "type": "string",
        }
    },
    "publication_date": {
        "type": "string",
        "description": "Blog post publication date"
    },
  }
}
```

## Available Options

(See also the Universal Options in the [Actions](/actions) top-level Documentation)

<OptionsTable
  rows={[
    {
      name: "goal",
      required: true,
      type: "string",
      default: null,
      description: "A natural language goal for the AI to try to achieve.",
    },
    {
      name: "schema",
      required: false,
      type: "object (see next section on this page)",
      default: "",
      description: <>A schema defining the desired output data structure</>,
    },
    {
      name: "validation",
      required: false,
      type: "object (see below)",
      default: "",
      description: (
        <>Validate the step's output set using these criteria(see below)</>
      ),
    },
    {
      name: "validation.required",
      required: false,
      type: "string[]",
      default: [],
      description: (
        <>
          Fail the step unless the output has all the keys specified in the
          provided array.
        </>
      ),
    },
    {
      name: "mode",
      required: false,
      type: '"textual" or "visual"',
      default: '"textual"',
      description: (
        <>
          Whether to process the current page as text or as an image when
          attempting to extract data. Typically, "textual" provides the best
          results, but "visual" can be necessary if data is present in graphics
          or for particularly complicated layouts. "visual" is used by default
          for PDFs.
        </>
      ),
    },
    {
      name: "write",
      required: false,
      type: "boolean",
      default: "true",
      description: (
        <>
          Whether or not to write the extracted data to the results datastore.
          Regardless of the value of this option, the data will be stored in the
          `data` of output States.
        </>
      ),
    },
    {
      name: "mergeOn",
      required: false,
      type: "string",
      default: "",
      description: (
        <>
          When a key name is provided for this option (and the 'write' option is
          true), the output will be merged with the output generated from the prior step
          that has the same value for the provided key. If you would like to merge the output of multiple steps, use mergeOn in each subsequent step. If 'write' is false, this option has no effect.
        </>
      ),
    },
    {
      name: "render",
      required: false,
      type: "boolean",
      default: "true",
      description: (
        <>
            If set to false, this action will skip rendering the input State, which can save time and money. Only set to false if you're certain that the step doesn't require the input State's page content (i.e. if it depends entirely on the input State's 'data').
        </>
      ),
    },

]}
/>

## Writing Schemas

The Schemas used in Indexical are a superset of the JSONSchema standard. Before writing any Schemas, it is important to familiarize yourself with the basics of JSONSchema here: [JSONSchema Getting Started Guide](https://json-schema.org/learn/getting-started-step-by-step).

In addition to JSON Schema, Indexical Schemas also support Indexical [Special Values](/values) and a few Indexical-specific data types.

To use a Special Value, just set a key in your schema to the Special Value string. For example, using the Example above, we could add the blog post's URL and content like so:

```json
{
  "action": "extract",
  "goal": "Get the basic information about the blog post",
  "schema": {
    "title": {
        "type": "string",
        "description": "Blog post title"
    },
    "authors" {
        "type": "array",
        "items": {
            "type": "string",
        }
    },
    "publication_date": {
        "type": "string",
        "description": "Blog post publication date"
    },
    "link": "$url",
    "content": "$mainContent"
  }
}
```

Make sure to read the [Special Values Documentation](/values) for the full list of Special Values.

Additionally, Indexical also supports the following `type`s (in addition to the ones offered by JSONSchema):

### sections

The `"sections"` type will resolve to an array of chunks of text, as defined by any section-headings present in the document. It can be useful for situations where you'd like to get all the text under a certain heading. Note that the output will always be an array, even when only one section is returned.

Building on the earlier example:

```json
{
  "action": "extract",
  "goal": "Get the basic information about the blog post",
  "schema": {
    "title": {
        "type": "string",
        "description": "Blog post title"
    },
    "authors" {
        "type": "array",
        "items": {
            "type": "string",
        }
    },
    "publication_date": {
        "type": "string",
        "description": "Blog post publication date"
    },
    "bio": {
        "type": "sections",
        "description": "Biographical info about the author."
    }
  }
}
```

This type is experimental, and currently only works on particularly well-structured documents.

### entities

The `"entities"` type will extract an array of entities from the text on the provided page. This type expects a list of categories describing what kind of entities are of-interest, as well as (optional but recommended) some examples of entity extraction on snippets of text. Example usage:

```json
{
  "action": "extract",
  "goal": "Get the basic information about the blog post",
  "schema": {
    "title": {
        "type": "string",
        "description": "Blog post title"
    },
    "authors" {
        "type": "array",
        "items": {
            "type": "string",
        }
    },
    "publication_date": {
        "type": "string",
        "description": "Blog post publication date"
    },
    "companies": {
        "type": "entities",
        "description": "Companies mentioned in the text.",
        "categories": [{
            "name": "COMPANY",
            "description": "A name of a specific company"
        }],
        "examples": [{
            "input": "The new product from TechTech is much better than the old one from their competitor SmartGadgets.",
            "output": ["TechTech", "SmartGadgets"]
        }]
    }
  }
}
```

## Relevant [Locators](/locators)

The `extract` action can utilize [Locators](/locators) that have a `key` corresponding to a `key` in the action's `schema`.
