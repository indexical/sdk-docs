---
title: "Strategies"
description: "Site-Specific Instructions for Indexical"
---

One of the features that makes Indexical pipelines special is their ability to self-improve over time in a transparent, interpretable fashion. This functionality depends on `Strategies`, which are site-specific JSON-based hints and instructions that many Indexical Transforms can generate and persist from run to run. For example, in web scraping Transforms, Strategies can include css/xpath selectors that indicate where certain information can be found on a page, or what elements to interact with.

## StrategyStores

Strategies are stored in objects called StrategyStores, which are just collections of Strategies grouped under an arbitrary developer-assigned name. When you create a Transform, you can provide the name for a StrategyStore to associate with that Transform, and all Strategies generated by the Transform will be stored under that name. Later, you can use the CLI or Dashboard to view and modify generated Strategies. All Indexical-provided Transforms can accept a StrategyStore name as a second argument. For example:

```ts
import { extract } from "indexical/dist/web";

const myTransform = extract({
  "goal": "Get the basic information about the blog post",
  "schema": {
    "title": {
        "type": "string",
        "description": "Blog post title"
    },
    "authors" {
        "type": "array",
        "items": {
            "type": "string",
        }
    },
    "publication_date": {
        "type": "string",
        "description": "Blog post publication date"
    },
    "bio": {
        "type": "sections",
        "description": "Biographical info about the author."
    }
  }
}, "blog-info"); // <-- StrategyStore name here
```

This will store all generated strategies in a StrategyStore named `blog-info`. Specific strategies will refer to specific keys within the Transform's schema, but they will remain scoped to the StrategyStore. Therefore, using the same StrategyStore name in a different Transform with a key in common with this schema will result in the same Strategies being used for both.

## Manual Strategies

Often, when building workflows that work across different websites, you'll wish to manually provide Strategies for certain sites, to guide LLM functionality. To do so, simply add the Strategy as a JSON object to the JSONL files in the `/strategies` folder of your project.

The JSONL file should be inside a directory with a name that matches the StrategyStore. Each JSON strategy should take up exactly one line in the file. You're free to choose any file name you like as long as the folder name matches the StrategyStore.

See `strategies/sample/index.jsonl` in a newly created project for an example. To use that sample StrategyStore, you would use the name `sample` as the StrategyStore name. 

## Strategy JSON

Strategies are represented by single JSON objects. For example:

```json
{
  "css": "h1.text-5xl",
  "key": "pageTitle",
  "domain": "docs.indexical.dev"
}
```

Below is a list of all the possible options you can provide in a manually created JSON strategy:

<ParamField query="domain" required>
  the domain (and subdomain) that the locator is valid for. Any states with URLs
  at this domain/subdomain will attempt to utilize this locator. Note that
  subdomains are required (i.e. a locator for `example.com` will **not** be used
  on `www.example.com/home`, but a locator for `www.example.com` will be used. )
</ParamField>
<ParamField query="key" required>
  Indicates what data this locator will provide. Typically, in an `extract` or
  `extract-many` step, the `key` would correspond to the key in the schema that
  the contents of the element indicated by this locator would correspond to.
  However, certain steps/functions also have special internal keys that can use
  locators. For example, the `$link` key, when provided to a `navigate-many`
  step, corresponds to the locator that will be used to identify the links to
  follow. Similarly, the `$container` key, when provided to an `extract-many`
  step, corresponds to the locator used for identifying each element in the list
  for which the LLM should extract.
</ParamField>

<ParamField query="weight">
  An integer indicating how "high-quality" the locator is; internally, when
  locators are generated, they'll be assigned a weight proportional to how
  generalizable they seem to be (i.e. how often they work on a domain). If
  providing locators manually, provide a very high weight to override all
  internally-generated locators (e.g. 99999999), or a very low one (e.g. 1) to
  function as a fallback only.
</ParamField>

<ParamField query="css">
  {" "}
  A css selector that matches the desired element (can be multiple selectors as a
  single string, comma-separated)
</ParamField>

<ParamField query="attribute">
  Indicates an attribute of the selected element to access instead of the
  element's content, in situations where the locator is resolved to text. Note
  that this is **only** for locators using CSS, snce XPath offers its own
  methods of attribute access
</ParamField>

<ParamField query="xpath">
  an XPath expression that matches the desired element
</ParamField>

## Special Keys
| Key | WebTransforms | Description |
| :---| :---          | :---        |
| `$link`     | NavigateMany | CSS/XPath selectors for identifying links to follow |
| `$url`      | Navigate | Specific URL to navigate to (e.g., "https://example.com/jobs") |
| `$next`  | NavigateMany, ExtractMany | CSS/XPath selector for the pagination "next" button |
| `$container`   | ExtractMany | CSS/XPath selectors defining elements that correspond one-to-one with desired output items (e.g., a row if trying to extract a full table of information) |
| `$scroll`  | Extract, ExtractMany, NavigateMany | CSS/XPath selector for the element to target when implementing infinite scroll functionality |
